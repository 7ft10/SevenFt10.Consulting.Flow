# Role of the Architect

A Software Architect provides a solution that the technical team can create and design for the entire application. A software architect should have expertise in the following areas âˆ’

#### Design Expertise

* Expert in software design, including diverse methods and approaches such as object-oriented design, event-driven design, etc.
* Lead the development team and coordinate the development efforts for the integrity of the design.
* Should be able to review design proposals and tradeoff among themselves.

#### Domain Expertise

* Expert on the system being developed and plan for software evolution.
* Assist in the requirement investigation process, assuring completeness and consistency.
* Coordinate the definition of domain model for the system being developed.

#### Technology Expertise

* Expert on available technologies that helps in the implementation of the system.
* Coordinate the selection of programming language, framework, platforms, databases, etc.

#### Methodological Expertise

* Expert on software development methodologies that may be adopted during SDLC (Software Development Life Cycle).
* Choose the appropriate approaches for development that helps the entire team.

#### Hidden Role of Software Architect

* Facilitates the technical work among team members and reinforcing the trust relationship in the team.
* Information specialist who shares knowledge and has vast experience.
* Protect the team members from external forces that would distract them and bring less value to the project.

#### Deliverables of the Architect

* A clear, complete, consistent, and achievable set of functional goals
* A functional description of the system, with at least two layers of decomposition
* A concept for the system
* A design in the form of the system, with at least two layers of decomposition
* A notion of the timing, operator attributes, and the implementation and operation plans
* A document or process which ensures functional decomposition is followed, and the form of interfaces is controlled















* **Implementation details** (that is, the folder structure of your repo)
* **Implementation** **design** decisions (Do you use server side or client side rendering? Relational or non-relational databases?)
* The **technologies** you choose (Do you use REST or GraphQl for your API? Python with Django or Node with Express for your back end?)
* **System** **design** decisions (like is your system a monolith or is it divided into microservices?)
* **Infrastructure** decisions (Do you host your software on premise or on a cloud provider?)
